generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
   isBlocked     Boolean   @default(false)  // Corrected the typo here
  password      String?   @db.VarChar(72)
  image         String?
  dob           DateTime?
  gender        String?
  phone         String?
  role          String    @default("user") // Can be 'user', 'mentor', 'admin'
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  accounts      Account[]
  mentorProfile Mentor?

  @@index([email])

}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(uuid())
  email   String
  token   String
  expires DateTime

  @@unique([email, token])
}

model OTP {
  id        Int      @id @default(autoincrement())
  token     String
  email     String
  createdAt DateTime @default(now())
  expiresAt DateTime

  @@index([email, token])
}

model Mentor {
  id          String    @id @default(uuid())
  userId      String    @unique
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  skills      MentorSkill[]  // Many-to-Many relation through a junction table
  documents   String[]  // Array of file paths or URLs for uploaded documents
  aboutMe     String?  // Short description or bio
  experiences Experience[]  // Array of experiences, could be a JSON object or structured data
  educations  Education[]  // Array of educational details, could be a JSON object or structured data
  languages   String[]  // Array of languages spoken
  verified    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Experience {
  id          String   @id @default(uuid())
  mentorId    String
  role        String
  company     String
  startDate   DateTime
  endDate     DateTime?
  description String?

  mentor Mentor @relation(fields: [mentorId], references: [id])
}

model Education {
  id          String   @id @default(uuid())
  mentorId    String
  degree      String
  institution String
  startDate   DateTime
  endDate     DateTime?
  description String?

  mentor Mentor @relation(fields: [mentorId], references: [id])
}
model Skill {
  id      String   @id @default(uuid())
  name    String   @unique
  description String?

  mentors MentorSkill[] // Relation through a junction table

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Junction Table for Mentor-Skill Many-to-Many Relation
model MentorSkill {
  mentorId String
  skillId  String

  mentor   Mentor @relation(fields: [mentorId], references: [id], onDelete: Cascade)
  skill    Skill  @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@id([mentorId, skillId]) // Composite primary key
}


// model Booking {
//   id         String   @id @default(uuid())
//   mentorId   String
//   userId     String
//   date       DateTime
//   duration   Int      // Duration in minutes
//   status     String   @default("pending") // 'pending', 'confirmed', 'canceled', 'completed'
//   createdAt  DateTime @default(now())
//   updatedAt  DateTime @updatedAt

//   mentor     Mentor   @relation(fields: [mentorId], references: [id], onDelete: Cascade)
//   user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@index([mentorId])
//   @@index([userId])
// }
